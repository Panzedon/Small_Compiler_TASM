I’ll tell you in advance, the project is very crude and there’s a lot of work to be done.

And so, this version is very different from the original course work; it has already been structured to allow adding support for new commands or new operands for existing commands.
In this version (for now), it also creates a listing file while saving bytes for strings to fill the object file (this is for the future).
A little later I will add comments for structures and functions.

At the same time, I plan to output part of the contents of main.cpp to another file in order to make a separate function to call the “compiler” itself.

lexical.cpp and lexical.h contain functions for parsing strings into lexemes, analyzing them, and assigning types to each lexeme.

first_view describes the functions for the first pass.

second_view implements the second pass.

error_handler contains a class for outputting errors to the listing file.

commands_types describes almost all the data needed for the compiler to work — opcodes for registers, various templates for different addressing types for analysis.

The compiler module contains the CallCompiler function, which invokes the first and second passes, handling the overall compilation process. 
It also outputs debugging information about the analyzed code to help track and verify the compilation steps.

The main.cpp file calls CallCompiler, passing it the name of the assembly source file. It also ensures that the output listing file analysis.lst is created during the compilation process.

The Listing folder is responsible for generating the listing file and filling strings with corresponding bytes for the object file.access data for commands, depending on the operands

Currently, the compiler is able to analyze the following constructs:

Identifiers
Identifiers may contain uppercase and lowercase Latin letters and digits. They must begin with a letter. Case is not significant (uppercase and lowercase are treated the same). The maximum length of an identifier is 7 characters.

Constants
The compiler supports hexadecimal, decimal, binary, and string constants.

Directives
Supported directives include END, SEGMENT (without operands), as well as ENDS, ASSUME.
The DB, DW, and DD directives are supported with a single operand — a constant (string constants are allowed only for DB).

Data and addressing size
Only 32-bit data and segment offsets are supported. 16-bit data and offsets are not used.

Memory operand addressing
The compiler supports base-indexed addressing with constant displacement and scaling, e.g., [edx+esi*4+6], [ebx+ecx*2+12], etc., including the use of the ptr operator to explicitly specify the operand type when necessary.

Segment override prefixes
Segment overrides can be specified explicitly. If needed, they are automatically generated by the translator.

Machine instructions
Currently supported instructions include:

POPAD

PUSH reg

NEG mem

ADC reg, imm

SBB reg, reg

LDS reg, mem

MOV mem, reg

AND mem, imm

JNAE

JMP (direct intersegment addressing)

Where:

reg — 8-bit or 32-bit general-purpose register

mem — memory operand address

imm — 8-bit or 32-bit immediate constant